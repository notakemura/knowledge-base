**DB の代表的な種類**  
RDB : Oracle, SQL Server, DB2, PostgreSQL, MySQL  
OODB : ObjectStore, Caché  
XMLDB :  
Hierarchical Database :  
NoSQL :

- KVS（Key-Value Store） : Redis, DynamoDB, Riak
- ドキュメント指向 : MongoDB, CouchDB
- カラム指向 : Cassandra, HBase
- グラフ DB : Neo4j, ArangoDB

---

DOA = データ中心アプローチ → 主流  
POA = プロセス（プログラム）中心アプローチ

---

**3 層スキーマ**  
外部スキーマ → ユーザ  
概念スキーマ → 開発者 ※外部スキーマと内部スキーマのデータ独立性を高める。インターフェース的な。  
内部スキーマ →DBMS

---

論理設計＝ DB 設計すること＝物理層の制約にとらわれず、プレゼンテーション層の見え方を定義すること  
① エンティティの抽出  
② エンティティの定義（様々な制約を考えること）  
③ 正規化  
④ER 図の作成

物理設計＝物理的な制約を考えること  
① テーブル定義  
② インデックス定義  
③ ハードウェアのサイジング（①② が決まらないと決められない。）  
④ ストレージの冗長化決定（〃）＝ RAIDO のどのパターンを採用するか。  
⑤ ファイルの物理配置決定（〃）＝データファイル、インデックスファイル、一時ファイル（サブクエリとか）のサイズは意識すべき。システムファイル、ログファイルは内部の動きに任せるくらいで良い。

Note：  
カラムの制約を考えるのは論理設計。インデックス定義は物理設計。  
内部スキーマの構造を理解してないと、物理設計するのは難しい。  
③④⑤ はクラウド時代なので意識できる機会が少なそう。

RAID ＝冗長化構成。複数のディスクに同じデータを書き込む。

---

**バックアップ**

- フルバックアップ  
  あるタイミングにおけるスナップショット。  
  バックアップの時間が長い。負荷が高い。
- 差分バックアップ  
  トランザクションログをもとに任意の時間の状態に戻す。  
  前回のフルバックアップからの差分をためていく。
- 増分バックアップ  
  差分バックアップとデータ再現の方法は同じ。  
  前回の任意のバックアップからの差分をためていく。  
  基準日＋次の日＋次の次の日...＋障害発生日のバックアップを合わせる必要がある。

リストア＝フルバックアップのファイルをデータベースに戻す。  
リカバリ＝差分（増分）バックアップしていたトランザクションログを適用する。  
ロールフォーワード＝データベースサーバに残っているトランザクションログを適用する。

※サーバー CPU の机上サイジング  
１．アクセスログで、レスポンスタイムとスループットを確認  
２．ハードウェアリソースを確認

- CPU 使用率
- メモリ
- ディスク
- ネットワーク

３．性能比を算出する

---

**正規化**  
正規化＝データの冗長性を排除すること。  
関数従属＝あるデータが決まればもう一方のデータが決まること。  
第一正規形＝データがスカラ値であること。  
第二正規形＝主キーの一部に対して関数従属しているカラムが無い状態（＝完全関数従属）。※主キーが複数ある場合にしか発生しない。  
第三正規形＝主キー以外に対して関数従属しているカラムが無い状態。  
ボイス－コッド正規形＝非キーからキーへの関数従属を無くした状態。

---

**ER 図**  
IE 記法＝鳥の足で表現する。  
IDEF1X ＝「多」の数（カーディナリティ）を表現できる。

多対多の場合（例えば学生テーブルと講義テーブルなど）  
→ 関連実体（物理：中間テーブル）を準備し、外部キーを配置する。

---

**論理設計とパフォーマンス**  
検索＝非正規化状態の方が低コスト  
更新＝正規化状態の方が低コスト  
→ 両者はトレードオフ。

Note：  
メンテナビリティを最優先というのが自分の思想。  
細かく分けていた方が保守はしやすいはず。
なので、いかなる場合も初期段階は正規化状態にする。問題が出てこれば非正規化する。

---

**非正規化とパフォーマンス**  
大きいテーブル同士を結合すると、一時ファイルのサイズが大きくなるなどシステムに負担がかかる。

結局、正規化と非正規化はトレードオフ。  
非正規化のデメリットは以下。  
・更新時のパフォーマンスが悪い。  
・データのリアルタイム性が低い。（非正規化により複数テーブルの更新が必要になると、いつのタイミングでやるのか？問題が発生する）  
・改修コストが大きい。（逆もしかり。実装が変わる。）

★ 論理設計には、論理層だけでなく物理層（ファイルやハードウェア）の知識も必要！！

---

**データベースとパフォーマンス**

B-tree インデックス

- 均一性  
  B-tree が平衡木であるため、どのキーのどのような値を指定しても、同程度の速度になる。  
  ※長期間の運用によっては、木のバランスが崩れることがある。
- 持続性  
  フルスキャン=O(n)  
  B-tree インデックス＝ O(log n)
- 処理汎用性  
  ノードの高さがあまり変化せず、すべての処理が O(log n)なので、安定してる。
- 非等値性  
  ＝以外の不等号や BETWEEN に対しても使える。
- 親ソート性  
  集約関数、ORDER BY、集合演算、OLAP 関数などは、内部でソートが行われている。**B-tree インデックスは構築時にキー値をソートして保持**しているので、ORDER BY 句のキーとして指定したらインデックスが効く。

Note：  
絞り込み率と検索条件を意識する！

インデックスが使われない例

- インデックス列に演算を行っている
- 索引列に対して SQL 関数を適用している
- IS NULL を使っている
- 否定形（<>）を用いる
- OR を用いる（IN だったら OK）
- LIKE を使っている
- 暗黙の型変換が行われている → 想定している型が同じかどうか

**統計情報**  
メタデータ＝テーブルやインデックスなどのデータについてのデータ。

ユーザ  
↓  
パーサ（構文チェック）  
↓  
オプティマイザ（実行計画を決める）←→ カタログマネージャ（統計情報の管理）  
↓  
テーブル

---

**論理設計のバットノウハウ**  
テーブル分割

- 水平分割  
  年度ごとに分けるなど。パーティションなどを使って分割したほうが効率がいい。
- 垂直分割

※パーティションは論理的に分割してるだけなのに対し、シャーディングは物理的にも分割する。  
※カラムベースデータベースを使用するという手もある。

Note：
バッドノウハウは他にも書いてたが、当たり前の内容が多かったので割愛。  
バッドノウハウがバッドである理由 として 可読性ーエンジニアはそんなに頭がよくない と書かれていて、グサッときた。

---

**論理設計のグレーノウハウ**  
オートインクリメントの PK を主キーにするのは合理的。  
→ 主キーは人工的な数値で不変であり、一意であることが永遠に求められるから。

オートインクリメント（オートナンバリング）の仕組み。

- シーケンスオブジェクト  
  一意な連番を出してくれるオブジェクト。MySQL にはない。
- ID  
  DBMS ごとに型が違うのが難点。移植性が低い。
