**DB の代表的な種類**  
RDB : Oracle, SQL Server, DB2, PostgreSQL, MySQL  
OODB : ObjectStore, Caché  
XMLDB :  
Hierarchical Database :  
NoSQL :

- KVS（Key-Value Store） : Redis, DynamoDB, Riak
- ドキュメント指向 : MongoDB, CouchDB
- カラム指向 : Cassandra, HBase
- グラフ DB : Neo4j, ArangoDB

---

DOA = データ中心アプローチ → 主流  
POA = プロセス（プログラム）中心アプローチ

---

**3 層スキーマ**  
外部スキーマ → ユーザ  
概念スキーマ → 開発者 ※外部スキーマと内部スキーマのデータ独立性を高める。インターフェース的な。  
内部スキーマ →DBMS

---

論理設計＝ DB 設計すること＝物理層の制約にとらわれず、プレゼンテーション層の見え方を定義すること  
① エンティティの抽出  
② エンティティの定義（様々な制約を考えること）  
③ 正規化  
④ER 図の作成

物理設計＝物理的な制約を考えること  
① テーブル定義  
② インデックス定義  
③ ハードウェアのサイジング（①② が決まらないと決められない。）  
④ ストレージの冗長化決定（〃）＝ RAIDO のどのパターンを採用するか。  
⑤ ファイルの物理配置決定（〃）＝データファイル、インデックスファイル、一時ファイル（サブクエリとか）のサイズは意識すべき。システムファイル、ログファイルは内部の動きに任せるくらいで良い。

Note：  
カラムの制約を考えるのは論理設計。インデックス定義は物理設計。  
内部スキーマの構造を理解してないと、物理設計するのは難しい。  
③④⑤ はクラウド時代なので意識できる機会が少なそう。

RAID ＝冗長化構成。複数のディスクに同じデータを書き込む。

---

**バックアップ**

- フルバックアップ  
  あるタイミングにおけるスナップショット。  
  バックアップの時間が長い。負荷が高い。
- 差分バックアップ  
  トランザクションログをもとに任意の時間の状態に戻す。  
  前回のフルバックアップからの差分をためていく。
- 増分バックアップ  
  差分バックアップとデータ再現の方法は同じ。  
  前回の任意のバックアップからの差分をためていく。  
  基準日＋次の日＋次の次の日...＋障害発生日のバックアップを合わせる必要がある。

リストア＝フルバックアップのファイルをデータベースに戻す。  
リカバリ＝差分（増分）バックアップしていたトランザクションログを適用する。  
ロールフォーワード＝データベースサーバに残っているトランザクションログを適用する。

※サーバー CPU の机上サイジング  
１．アクセスログで、レスポンスタイムとスループットを確認  
２．ハードウェアリソースを確認

- CPU 使用率
- メモリ
- ディスク
- ネットワーク

３．性能比を算出する

---

**正規化**  
正規化＝データの冗長性を排除すること。  
関数従属＝あるデータが決まればもう一方のデータが決まること。  
第一正規形＝データがスカラ値であること。  
第二正規形＝主キーの一部に対して関数従属しているカラムが無い状態（＝完全関数従属）。※主キーが複数ある場合にしか発生しない。  
第三正規形＝主キー以外に対して関数従属しているカラムが無い状態。  
ボイス－コッド正規形＝非キーからキーへの関数従属を無くした状態。

---

**ER 図**
IE 記法＝鳥の足で表現する。  
IDEF1X ＝「多」の数（カーディナリティ）を表現できる。

多対多の場合（例えば学生テーブルと講義テーブルなど）  
→ 関連実体（物理：中間テーブル）を準備し、外部キーを配置する。

---

**論理設計とパフォーマンス**
検索＝非正規化状態の方が低コスト  
更新＝正規化状態の方が低コスト  
→ 両社はトレードオフ。

Note：  
メンテナビリティを最優先というのが自分の思想。  
細かく分けていた方が保守はしやすいはず。
なので、いかなる場合も初期段階は正規化状態にする。問題が出てこれば非正規化する。
